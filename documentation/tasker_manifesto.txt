This is a list of things(technical concerns) we'd like to consider:

*Exceptions:
            -When do we decide to check exceptions?
            -For what classes/objects do we make exceptions?
            -What will be the action(s) that exceptions take?

*OOP:
     -C++ ALLOWS programmers to enforce OOP, but it DOES NOT "force" it like languages
      such as Java/C#
     -How strict should we be with enforcing an OOP-style code design?
     -Should we have ANY functional/non-OOP components?
     

argument passing to functions: 

I grabbed this from a book because I thought it was worth discussing
-----------------------------------------------------------------------------------------------
8.5.6 Pass-by-value vs. pass-by-reference
When should you use pass-by-value, pass-by-reference, and pass-by-const-reference? Consider first a technical example:
Click here to view code image
void f(int a, int& r, const int& cr)
{
          ++a;            // change the local a
          ++r;            // change the object referred to by r
          ++cr;          // error: cr is const
}

If you want to change the value of the object passed, you must use a non-const reference: pass-by-value gives you a copy and pass-by-const-reference prevents you from changing the value of the object passed. So we can try
Click here to view code image
void g(int a, int& r, const int& cr)

{
          ++a;                  // change the local a
          ++r;                  // change the object referred to by r
          int x = cr;         // read the object referred to by cr
}
int main()
{
          int x = 0;
          int y = 0;
          int z = 0;

          g(x,y,z);      // x==0; y==1; z==0
          g(1,2,3);      // error: reference argument r needs a variable to refer to
          g(1,y,3);      // OK: since cr is const we can pass a literal
}

So, if you want to change the value of an object passed by reference, you have to pass an object. Technically, the integer literal 2 is just a value (an rvalue), rather than an object holding a value. What you need for g()’s argument r is an lvalue, that is, something that could appear on the left-hand side of an assignment.
Note that a const reference doesn’t need an lvalue. It can perform conversions exactly as initialization or pass-by-value. Basically, what happens in that last call, g(1,y,3), is that the compiler sets aside an int for g()’s argument cr to refer to:
Click here to view code image

g(1,y,3);      // means: int__compiler_generated = 3; g(1,y,__compiler_generated)

Such a compiler-generated object is called a temporary object or just a temporary.
Our rule of thumb is:

1. Use pass-by-value to pass very small objects.
2. Use pass-by-const-reference to pass large objects that you don’t need to modify.
3. Return a result rather than modifying an object through a reference argument.
4. Use pass-by-reference only when you have to.
These rules lead to the simplest, least error-prone, and most efficient code. By “very small” we mean one or two ints, one or two doubles, or something like that. If we see an argument passed by non-const reference, we must assume that the called function will modify that argument.
That third rule reflects that you have a choice when you want to use a function to change the value of a variable. Consider:
Click here to view code image
int incr1(int a) { return a+1; }          // return the new value as the result
void incr2(int& a) { ++a; }                // modify object passed as reference


int x = 7;
x = incr1(x);                                        // pretty obvious
incr2(x);                                              // pretty obscure


Why do we ever use non-const-reference arguments? Occasionally, they are essential
• For manipulating containers (e.g., vector) and other large objects
• For functions that change several objects (we can have only one return value)
For example:
Click here to view code image
void larger(vector<int>& v1, vector<int>& v2)
          // make each element in v1 the larger of the corresponding
          // elements in v1 and v2;
          // similarly, make each element of v2 the smaller
{
          if (v1.size()!=v2.size()) error("larger(): different sizes");
          for (int i=0; i<v1.size(); ++i)
                    if (v1[i]<v2[i])
                              swap(v1[i],v2[i]);
}
void f()
{
vector<int> vx;
          vector<int> vy;
          // read vx and vy from input
          larger(vx,vy);
          // . . .
}

Using pass-by-reference arguments is the only reasonable choice for a function like larger().
It is usually best to avoid functions that modify several objects. In theory, there are always alternatives, such as returning a class object holding several values. However, there are a lot of programs “out there” expressed in terms of functions that modify one or more arguments, so you are likely to encounter them. For example, in Fortran — the major programming language used for numerical calculation for about 50 years — all arguments are traditionally passed by reference. Many numeric programmers copy Fortran designs and call functions written in Fortran. Such code often uses pass-by-reference or pass-by-const-reference.

If we use a reference simply to avoid copying, we use a const reference. Consequently, when we see a non-const-reference argument, we assume that the function changes the value of its argument; that is, when we see a pass-by-non-const-reference we assume that not only can that function modify the argument passed, but it will, so that we have to look extra carefully at the call to make sure that it does what we expect it to.
